<!DOCTYPE html>
<html>

<head>
    <meta http-equiv='cache-control' content='no-cache'>
    <meta http-equiv='expires' content='0'>
    <meta http-equiv='pragma' content='no-cache'>
</head>

<body>
    <h3>Rendered component</h3>
    <div style="width: 100%; height: 300px; background-color: #fafafa; border: 1px solid #e4e4e4;">
        <iframe id="sb-target" style="width: 100%; height: 100%; background-color: transparent"></iframe>
    </div>
    <div id="status" style="width: 100%; border: 1px solid #e8e8e8; background-color: #fbfbfb; display: flex; align-content: center; align-items: center; padding: 16px;"></div>
    <div style="display: flex; flex-direction: row; height: 600px; width: 100%;">
        <div style="flex: 1; flex-basis: 100%;margin: 16px">
            <h3>Package.json configuration</h3>
            <textarea id="package" style="width: 100%; height: 100%; background-color: #fafafa; border: 1px solid #e4e4e4; padding: 16px;">
{
    "name": "supernova-live-react",
    "version": "1.0.0",
    "description": "Live React Code Packager",
    "keywords": ["react", "supernova"],
    "main": "src/index.js",
    "dependencies": {
        "react-dom": "latest",
        "react": "latest"
    },
    "devDependencies": {
        "@babel/runtime": "7.13.8",
        "typescript": "4.1.3"
    },
    "scripts": {
        "start": "react-scripts start",
        "build": "react-scripts build",
        "test": "react-scripts test --env=jsdom",
        "eject": "react-scripts eject"
    },
    "browserslist": [">0.2%", "not dead", "not ie <= 11", "not op_mini all"]
}
            </textarea>
        </div>
        <div style="flex: 1; flex-basis: 100%; margin: 16px">
            <h3>Code to render</h3>
            <textarea id="code" style="width: 100%; height: 100%; background-color: #fafafa; border: 1px solid #e4e4e4; padding: 16px;">
import React from "react";

export default function IconButtonSizes() {
    return (
        <div>Content</div>
    );
}
            
            </textarea>
        </div>
    </div>

    <!-- Import library -->
    <script src="rtcp-core.js"></script>
    <script>
        // Encode sandbox data from textareas providing content
        function getEncodedSandboxData(renderer) {
            // Get code and package data, and encode the sandbox information
            const code = document.getElementById("code").value
            const package = document.getElementById("package").value

            // Note: This creates base64-encoded string that contains all neccessary information to render the iframe
            // Only allowed option is "react" for now, we'll add more later (angular, vue)
            return renderer.encodeSandboxData("react", code, package)
        }

        // Simple debounce so we are not trashing compiler
        const debounce = (func, wait) => {
            let timeout;

            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };

                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // ---- Access rendering engine. I made it so it is prepared for you by default without anything, just access new property
        const engine = window.sandboxEngine;

        // ---- Handling observer and notifications coming from renderer - must be setup before setting the sandboxes
        engine.setObserver((message) => {
            let element = document.getElementById("status")
            let userMessage = `Status: ${message.status}`
            if (message.error) {
                userMessage += `, error message: ${message.error}`
            }
            element.innerText = userMessage
            let color = "fbfbfb";

            switch (message.status) {
                case "done":
                    color = "d7ffe0";
                    break
                case "error":
                    color = "ffd7e0";
                    break
                default:
                    color = "fbfbfb";
                    break
            }
            element.style.backgroundColor = `#${color}`

            // It is possible to know to which target the message belongs by accessing `.sandboxId` property
            // const id = message.sandboxId
        })

        // ---- Handling initial load of sandbox(es) ----

        // Current target equal to unique element, iframe or div (use iframe)
        const renderingTarget = "sb-target"

        // Inject encoded data to the iframe tag. This should be called for every iframe that was spawned
        const encodedInitialData = getEncodedSandboxData(engine)
        engine.setSandboxDataBeforeLoad(renderingTarget, encodedInitialData)

        // Build sandbox for specific frame. This needs to be called after setting data, before everything else.
        engine.buildSandbox(renderingTarget)

        // or build in bulk: engine.buildSandboxStartingWith(renderingTarget)
        // or build in bulk: engine.buildSandboxEndingWith(renderingTarget)

        // ---- Updating sandbox(es) ----

        // Hook update events
        const codeUpdate = debounce(function() {
            // Update sandbox on every content change, debounced
            // We get encoded data again
            const encodedData = getEncodedSandboxData(engine)

            // And we update sandbox, using the ID we provided when constructing the iframe
            engine.updateSandbox(renderingTarget, encodedData)
        }, 1000)

        // Observers for both textfields
        document.getElementById("code").addEventListener('input', function() {
            codeUpdate()
        }, false);
        document.getElementById("package").addEventListener('input', function() {
            codeUpdate()
        }, false);
    </script>
</body>

</html>